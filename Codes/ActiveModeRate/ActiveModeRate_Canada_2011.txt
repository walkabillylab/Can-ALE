library(cancensus)
library(sf)
library(dplyr)
library(future)
library(future.apply)
library(writexl)


# USER SETTINGS
# Set to your CensusMapper API key
api_key    <- "CensusMapper_723e3f4e60999d1127c93026d17c3b50"
# Writable folder for cancensus cache
cache_path <- "V:/CanALE/AMR"
# Output file path
out_xlsx   <- "V:/CanALE/AMR/commute_rates_CA11_Canada_buffer1km.xlsx"
# Number of CPU cores to use for parallel processing
workers    <- 5


# 1)  API key & cache 
set_cancensus_api_key(api_key, install = FALSE)
Sys.setenv(CM_CACHE_PATH = cache_path)


# 2)  Define provinces and census vectors 
province_pruids <- c("10", "11", "12", "13", "24", "35", "46", "47", "48", "59", "60", "61", "62")

# Vectors for 2011 National Household Survey 
commute_vectors_2011 <- c(
  "v_CA11N_2191",  # Total - Main mode of transportation
  "v_CA11N_2203",  # Walked
  "v_CA11N_2206",  # Bicycle
  "v_CA11N_2200"   # Public transit
)

# This will hold the results from each province
all_provinces_agg <- list()


# 3) Loop through each province to process data 
for (pruid in province_pruids) {
  
  message(sprintf("\n---\nProcessing PRUID: %s\n---", pruid))
  
  # 3.1) Download DA geometries + commuting counts for the province
  da_sf <- get_census(
    dataset    = "CA11", # Use CA11 for NHS
    regions    = list(PR = pruid),
    vectors    = commute_vectors_2011,
    level      = "DA",
    geo_format = "sf",
    use_cache  = TRUE
  )
  
  # Skip to next province if no data was returned
  if (is.null(da_sf) || nrow(da_sf) == 0) {
    message("No data found for PRUID: ", pruid, ". Skipping.")
    next
  }
  
  # 3.2) Rename long headers for clarity
  da_sf <- da_sf %>%
    rename(
      total_labour_force = `v_CA11N_2191: Total employed population aged 15 years and over with a usual place of work or no fixed workplace address by mode of transportation`,
      walked             = `v_CA11N_2203: Walked`,
      bicycled           = `v_CA11N_2206: Bicycle`,
      transit            = `v_CA11N_2200: Public transit`
    )
  
  # 3.3) Reproject & build 1-km buffers
  sc_lambert <- 3347 # NAD83 / Statistics Canada Lambert
  da_lam     <- st_transform(da_sf, sc_lambert)
  centroids  <- st_centroid(da_lam)
  buffers    <- st_buffer(centroids, 1000) %>% select(GeoUID)
  
  # 3.4) Parallel area-weighting
  plan(multisession, workers = workers)
  sf::sf_use_s2(FALSE) # Use planar geometry for speed
  
  buffer_worker <- function(i) {
    buf <- buffers[i, ]
    id  <- buf$GeoUID
    
    inter <- suppressWarnings(st_intersection(da_lam, buf))
    if (nrow(inter) == 0) {
      return(data.frame(
        GeoUID_buf = id, walk = 0, bike = 0, trans = 0, total = 0,
        area_buf_m2 = as.numeric(st_area(buf))
      ))
    }
    
    inter <- inter %>%
      mutate(
        # Get original area of the DA before intersection
        da_area   = st_area(da_lam[match(GeoUID, da_lam$GeoUID), ]),
        part_area = st_area(geometry),
        # Calculate the fraction of the DA inside the buffer
        frac      = pmin(as.numeric(part_area / da_area), 1)
      )
    
    # Summarise the weighted counts within the buffer
    agg <- inter %>%
      summarise(
        walk  = sum(walked   * frac, na.rm = TRUE),
        bike  = sum(bicycled * frac, na.rm = TRUE),
        trans = sum(transit  * frac, na.rm = TRUE),
        total = sum(total_labour_force * frac, na.rm = TRUE),
        .groups = "drop"
      )
    
    data.frame(
      GeoUID_buf = id,
      walk       = agg$walk,
      bike       = agg$bike,
      trans      = agg$trans,
      total      = agg$total,
      area_buf_m2= as.numeric(st_area(buf))
    )
  }
  
  agg_df <- future_lapply(seq_len(nrow(buffers)), buffer_worker, future.seed = FALSE) |>
    bind_rows()
  
  # Add the province's results to the list
  all_provinces_agg[[pruid]] <- agg_df
  



# 4) Combine results from all provinces 

final_df <- bind_rows(all_provinces_agg)


# 5)  Compute final rates 
final <- final_df %>%
  mutate(
    # Use area-weighted totals to calculate rates
    walk_rate = ifelse(total == 0, NA, walk / total),
    active_transport_rate = ifelse(total == 0, NA, (walk + bike + trans) / total)
  ) %>%
  # Rename GeoUID column and reorder for clarity
  select(GeoUID = GeoUID_buf, walk_rate, active_transport_rate, total, walk, bike, trans, area_buf_m2)


# 6)  Export to Excel 
write_xlsx(final, out_xlsx)
