# Processing one province at a time to reduce memory load and avoid slowing down the PC (Just for 2021)

# 0) Libraries 
library(cancensus)
library(sf)
library(dplyr)
library(future)
library(future.apply)
library(writexl)


# USER SETTINGS 
pruid      <- "62"   # 10 = NL.  Change to 11, 12, 24, 35, 46, 47, 48, 59, 60, 61, 62 …
out_xlsx   <- sprintf("V:/CanALE/AMR/commute_rates_CA21_PR%s_buffer1km.xlsx", pruid)
cache_path <- "V:/CanALE/AMR"   # writable folder for cancensus cache
workers    <- 5                   # leave one CPU core free
 


# 1)  API key & cache 
set_cancensus_api_key("CensusMapper_723e3f4e60999d1127c93026d17c3b50",
                      install = FALSE)
Sys.setenv(CM_CACHE_PATH = cache_path)

# 2)  Census vectors 
commute_vec <- c(
  "v_CA21_7632",   # Total labour force
  "v_CA21_7647",   # Walked
  "v_CA21_7650",   # Bicycle
  "v_CA21_7644"    # Public transit
)

message("  Downloading DA geometries + commuting counts for PRUID = ", pruid, " …")
da_sf <- get_census(
  dataset    = "CA21",
  regions    = list(PR = pruid),
  vectors    = commute_vec,
  level      = "DA",
  geo_format = "sf",
  use_cache  = TRUE
)

# 3)  Rename long headers 
da_sf <- da_sf %>%
  rename(
    total_labour_force = `v_CA21_7632: Total - Main mode of commuting for the employed labour force aged 15 years and over with a usual place of work or no fixed workplace address`,
    walked             = `v_CA21_7647: Walked`,
    bicycled           = `v_CA21_7650: Bicycle`,
    transit            = `v_CA21_7644: Public transit`
  )

# 4)  Reproject & build 1-km buffers 
sc_lambert <- 3347
da_lam     <- st_transform(da_sf, sc_lambert)
centroids  <- st_centroid(da_lam)
buffers    <- st_buffer(centroids, 1000) %>% select(GeoUID)

# 5)  Parallel area-weighting 
plan(multisession, workers = workers)
sf::sf_use_s2(FALSE)    # planar for speed

buffer_worker <- function(i) {
  buf <- buffers[i, ]
  id  <- buf$GeoUID
  
  inter <- suppressWarnings(st_intersection(da_lam, buf))
  if (nrow(inter) == 0) {
    return(data.frame(
      GeoUID_buf = id,
      walk = 0, bike = 0, trans = 0, total = 0,
      area_buf_m2 = as.numeric(st_area(buf))
    ))
  }
  
  inter <- inter %>%
    mutate(
      da_area   = st_area(da_lam[match(GeoUID, da_lam$GeoUID), ]),
      part_area = st_area(geometry),
      frac      = pmin(as.numeric(part_area / da_area), 1)
    )
  
  agg <- inter %>%
    summarise(
      walk  = sum(walked   * frac, na.rm = TRUE),
      bike  = sum(bicycled * frac, na.rm = TRUE),
      trans = sum(transit  * frac, na.rm = TRUE),
      total = sum(total_labour_force * frac, na.rm = TRUE),
      .groups = "drop"
    )
  
  data.frame(
    GeoUID_buf = id,
    walk       = agg$walk,
    bike       = agg$bike,
    trans      = agg$trans,
    total      = agg$total,
    area_buf_m2= as.numeric(st_area(buf))
  )
}

agg_df <- future_lapply(seq_len(nrow(buffers)), buffer_worker, future.seed = FALSE) |>
  bind_rows()

# 6)  Compute rates 
final <- agg_df %>%
  mutate(
    walk_rate             = ifelse(total == 0, NA, walk  / total),
    active_transport_rate = ifelse(total == 0, NA, (walk + bike + trans) / total)
  ) %>%
  select(GeoUID = GeoUID_buf, everything())

# 7)  Export 
write_xlsx(final, out_xlsx)
