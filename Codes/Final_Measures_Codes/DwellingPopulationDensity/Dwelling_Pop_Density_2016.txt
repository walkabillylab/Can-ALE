

# Load the required libraries
start_time_all <- Sys.time()

library(cancensus)
library(sf)
library(dplyr)
library(writexl)
library(purrr)
library(future)
library(future.apply)

# 1. SETUP CACHE FOLDER & API KEY
set_cancensus_cache_path("V:/CanALE/cache", install = TRUE, overwrite = TRUE)
set_cancensus_api_key("CensusMapper_723e3f4e60999d1127c93026d17c3b50", install = TRUE, overwrite = TRUE)

# Parallel Processing
plan(multisession, workers = 5)
options(future.globals.maxSize = 4 * 1024^3) 

# 2. DEFINE REQUIRED DATA PATHS AND PROVINCE LIST
da_path <- "V:/CanALE/Data/DA/DA_2016/lda_000b16a_e.shp"
centroid_path <- "V:/CanALE/Data/PopWeighted_Centroid/DA_2016_hybrid_centroids_Canada.gpkg"
db_path <- "V:/CanALE/Data/DB/DB_2016/ldb_000b16a_e.shp"
output_base_path <- "V:/CanALE/Data/DwellingPopulation/2016" 

provinces <- list(
  "NL" = "10", "PE" = "11", "NS" = "12", "NB" = "13",
  "QC" = "24", "ON" = "35", "MB" = "46", "SK" = "47",
  "AB" = "48", "BC" = "59", "YK" = "60", "NWT" = "61", "NU" = "62"
)

# 3. LOAD ALL REQUIRED DATA

DA_Canada <- st_read(da_path, quiet = TRUE)
DB_Canada_Shapes <- st_read(db_path, quiet = TRUE)
All_Centroids_Canada <- st_read(centroid_path, quiet = TRUE)

# 4. START LOOPING THROUGH EACH PROVINCE
for (prov_abbr in names(provinces)) {
  pruid <- provinces[[prov_abbr]]
  
  start_time_province <- Sys.time()
  
  # --- Filter master files for the current province ---
  DA_prov <- DA_Canada %>% filter(PRUID == pruid)
  
  db_shapes <- DB_Canada_Shapes %>% filter(PRUID == pruid)
  
  da_centroids <- All_Centroids_Canada %>%
    mutate(PRUID = substr(DAUID, 1, 2)) %>%
    filter(PRUID == pruid) %>%
    st_transform(3347)
  
  # Fetch census data 
  db_census_data <- get_census(
    dataset = "CA16",
    regions = list(PR = pruid),
    vectors = c("v_CA16_401", "v_CA16_404"),
    level = "DB",
    geo_format = NA
  ) %>%
    rename(
      population_2016 = Population,
      private_dwellings_2016 = Dwellings
    )
  
  # Prepare the provincial DB layer for interpolation 
  prov_db_data_3347 <- db_shapes %>%
    inner_join(db_census_data, by = c("DBUID" = "GeoUID")) %>%
    st_transform(3347) %>%
    filter(!is.na(population_2016) & !is.na(private_dwellings_2016)) %>%
    mutate(area_original = st_area(.))
  
  # Create buffers 
  da_buffers <- st_buffer(da_centroids, dist = 1000)
  
  # Pre-calculate all intersection candidates at once
  all_candidate_indices <- st_intersects(da_buffers, prov_db_data_3347)
  
  # Define the calculation function
  buffer_intersect_db <- function(i) {
    one_buffer  <- da_buffers[i, ]
    buffer_id   <- one_buffer$DAUID
    
    # Use the pre-calculated list of candidates
    candidate_indices <- all_candidate_indices[[i]]
    
    if (length(candidate_indices) == 0) {
      return(data.frame(DAUID = buffer_id, pop_in_buffer = 0, dwel_in_buffer = 0))
    }
    
    candidate_dbs <- prov_db_data_3347[candidate_indices, ]
    
    inter <- suppressWarnings(st_intersection(candidate_dbs, one_buffer))
    
    if (nrow(inter) == 0) {
      return(data.frame(DAUID = buffer_id, pop_in_buffer = 0, dwel_in_buffer = 0))
    }
    
    inter <- inter %>%
      mutate(
        area_part     = st_area(geometry),
        frac          = pmin(as.numeric(area_part / area_original), 1)
      )
    
    pop_sum  <- sum(inter$population_2016 * inter$frac, na.rm = TRUE)
    dwel_sum <- sum(inter$private_dwellings_2016 * inter$frac, na.rm = TRUE)
    
    data.frame(
      DAUID          = buffer_id,
      pop_in_buffer  = pop_sum,
      dwel_in_buffer = dwel_sum
    )
  }
  
  # Parallel Calculation
  results_list <- future_lapply(seq_len(nrow(da_buffers)), buffer_intersect_db, future.seed = FALSE)
  results_df   <- do.call(rbind, results_list)
  
  # 5. FINALIZE RESULTS
  all_da_ids <- st_drop_geometry(DA_prov) %>% select(DAUID)
  
  final_results <- all_da_ids %>%
    left_join(results_df, by = "DAUID") %>%
    mutate(
      pop_in_buffer = ifelse(is.na(pop_in_buffer), 0, pop_in_buffer),
      dwel_in_buffer = ifelse(is.na(dwel_in_buffer), 0, dwel_in_buffer),
      pop_density_1km  = pop_in_buffer / pi,
      dwel_density_1km = dwel_in_buffer / pi
    ) %>%
    select(DAUID, pop_density_1km, dwel_density_1km, pop_in_buffer, dwel_in_buffer)
  
  output_filename <- paste0("province_", pruid, "_dwelling_population_density_1km_2016_DB_weighted.xlsx")
  output_path <- file.path(output_base_path, output_filename)
  write_xlsx(final_results, output_path)
  
  end_time_province <- Sys.time()
  cat("--- Completed", prov_abbr, "in", difftime(end_time_province, start_time_province, units="mins"), "minutes ---\n")
}

